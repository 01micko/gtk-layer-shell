# GTK Layer Shell tests
This directory is home to the gtk-layer-shell test suite.

## To run tests
`ninja -C build test` (where `build` is the path to your build directory).

### To add a new test
1. Copy an existing test client
2. Set the new expected protocol messages and implementation
3. Add its name to the `test_clients` list in `test/meson.build`

## Scrpts
- `check-licenses.py` makes sure all files have licenses at the top
- `tests-not-enabled.py` is only run if tests are disabled, and explains to the user how to enable them
- `run-integration-test.py` runs a single integration test

## Integration tests
Most of the potential bugs in GTK Layer Shell arise from interactions between the library, GTK and the Wayland compositor, so unit tests aren't particularly useful. The integration tests consist of the following components:

### Test clients
Each integration test is a single unique GTK app that uses GTK Layer Shell (called a test client). All test clients are located in `test-clients`. Anything common to multiple test clients gets pulled into `test-client-common`. Test clients can make assertions and protocol expectations. See expectations format below. Each meson test runs a single test client.

### Expectations format
Test clients emit protocol expectations by using the `EXPECT_MESSAGE` macro. Each expectation is a white-space-separated sequence of tokens written to a line of stdout. The first element must be `WL:` (this is automatically inserted by `EXPECT_MESSAGE`). Every following token must appear within a message line in order for the expectation to match a message. The order of tokens on a single line does not matter. The list of expected messages must match in the correct order. Messages are matched against the output of the client run with `WAYLAND_DEBUG=1`. Events and requests are not distinguished, as that's more likely to lead to confusing test bugs than it is to detect actual bugs.

### Test runner
`ninja -C build test` will run `run-integration-test.py` for each test defined in `test/meson.build`. This script:
- Creates a temporary directory in `/tmp` to serve as `XDG_RUNTIME_DIR` (this allows tests to run in parallel without interfering with each other)
- Spins up a mock Wayland server
- Runs the given mock client within it
- (Both are run with `WAYLAND_DEBUG=1` so protocol messages are written to stderr by libwayland)
- Ensures both the client and server exit successfully
- Parses the client's protocol message expectations
- Ensures they match the protocol messages generated by libwayland

### Mock server
Rather than running the integration tests in an external Wayland compositor, we implement our own mock Wayland compositor (located in `mock-server`). This doesn't show anything on-screen or get real user input, it simply gives the required responses to protocol messages. It's only dependency is libwayland. It implements most of the protocol with a single default dispatcher. This reads the message signature and takes whatever action appears to be required. The behavior of some messages is overridden.
